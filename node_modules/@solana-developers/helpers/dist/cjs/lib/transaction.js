"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSimulationComputeUnits = exports.confirmTransaction = void 0;
const web3_js_1 = require("@solana/web3.js");
const logs_1 = require("./logs");
const confirmTransaction = async (connection, signature, commitment = "finalized") => {
    const block = await connection.getLatestBlockhash();
    const rpcResponse = await connection.confirmTransaction({
        signature,
        ...block,
    }, commitment);
    (0, logs_1.getErrorFromRPCResponse)(rpcResponse);
    return signature;
};
exports.confirmTransaction = confirmTransaction;
// Was getSimulationUnits
// Credit https://twitter.com/stegabob, originally from
// https://x.com/stegaBOB/status/1766662289392889920
const getSimulationComputeUnits = async (connection, instructions, payer, lookupTables) => {
    const testInstructions = [
        // Set an arbitrarily high number in simulation
        // so we can be sure the transaction will succeed
        // and get the real compute units used
        web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: 1400000 }),
        ...instructions,
    ];
    const testTransaction = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
        instructions: testInstructions,
        payerKey: payer,
        // RecentBlockhash can by any public key during simulation
        // since 'replaceRecentBlockhash' is set to 'true' below
        recentBlockhash: web3_js_1.PublicKey.default.toString(),
    }).compileToV0Message(lookupTables));
    const rpcResponse = await connection.simulateTransaction(testTransaction, {
        replaceRecentBlockhash: true,
        sigVerify: false,
    });
    (0, logs_1.getErrorFromRPCResponse)(rpcResponse);
    return rpcResponse.value.unitsConsumed || null;
};
exports.getSimulationComputeUnits = getSimulationComputeUnits;
//# sourceMappingURL=transaction.js.map